"""
ZeroWall — Exploit Agent
=========================
Replays known attack payloads against each mutation candidate to
determine if the exploit still works after transformation.

SAFETY NOTICE:
- All payloads target ONLY the local demo app container
- Payloads are pre-defined and non-harmful (simulated patterns only)
- No real exploit code, no real command execution, no network scanning
"""

import time
import logging
import asyncio
from typing import List, Dict, Any, Optional
import httpx

from core.models import CandidateResult, ExploitPayload

logger = logging.getLogger(__name__)


# Known exploit payloads for the demo target app
# These trigger the SIMULATED vulnerability patterns — zero real harm
KNOWN_PAYLOADS: List[ExploitPayload] = [
    ExploitPayload(
        payload_id="path-traversal-001",
        name="Simulated Path Traversal",
        target_endpoint="/data",
        method="GET",
        params={"file": "../../etc/passwd"},
        expected_vuln_indicator="SIMULATED",  # vuln: returns response instead of 403
        description="Path traversal pattern on /data endpoint — blocked by allowlist in hardened version",
    ),
    ExploitPayload(
        payload_id="cmd-injection-001",
        name="Simulated Command Injection",
        target_endpoint="/run",
        method="POST",
        body={"cmd": "rm -rf /"},
        expected_vuln_indicator="unknown",  # vuln: returns status=unknown instead of 400
        description="Command injection probe on /run endpoint — blocked by allowlist in hardened version",
    ),
    ExploitPayload(
        payload_id="sqli-001",
        name="Simulated SQL Injection",
        target_endpoint="/search",
        method="GET",
        params={"q": "' OR 1=1 --"},
        expected_vuln_indicator="' OR 1=1",  # vuln: raw query echoed back
        description="SQLi reflection probe on /search — allowlist regex blocks in hardened version",
    ),
    ExploitPayload(
        payload_id="cmd-injection-002",
        name="Shell Escape Probe",
        target_endpoint="/run",
        method="POST",
        body={"cmd": "; ls -la"},
        expected_vuln_indicator="unknown",
        description="Shell escape sequence injection on /run",
    ),
    ExploitPayload(
        payload_id="path-traversal-002",
        name="Config File Access",
        target_endpoint="/data",
        method="GET",
        params={"file": "../../config/secrets.yaml"},
        expected_vuln_indicator="SIMULATED",
        description="Config file path traversal on /data",
    ),
]


class ExploitAgent:
    """
    Replays exploit payloads against each mutation candidate.
    Tests each candidate at a specific port offset, or via in-process testing.
    """

    def __init__(
        self,
        base_url: str = "http://localhost:8000",
        payloads: Optional[List[ExploitPayload]] = None,
        timeout_s: float = 5.0,
        workers: int = 4,
    ):
        self.base_url = base_url
        self.payloads = payloads or KNOWN_PAYLOADS
        self.timeout_s = timeout_s
        self.workers = workers

    async def replay_against_candidate(
        self,
        candidate: CandidateResult,
        target_url: Optional[str] = None,
    ) -> CandidateResult:
        """
        Replay all known exploit payloads against this candidate's running instance.
        Updates candidate in-place with exploit metrics.
        """
        url = target_url or self.base_url
        logger.info(
            f"[ExploitAgent] Replaying {len(self.payloads)} payloads "
            f"against {candidate.candidate_id} at {url}"
        )

        t_start = time.time()
        successes = 0
        failures = 0
        attempts = 0

        async with httpx.AsyncClient(timeout=self.timeout_s) as client:
            for payload in self.payloads:
                try:
                    result = await self._fire_payload(client, url, payload)
                    attempts += 1
                    if result["exploited"]:
                        successes += 1
                        logger.debug(
                            f"[ExploitAgent] ✗ EXPLOIT SUCCEEDED: {payload.payload_id} "
                            f"on {candidate.candidate_id}"
                        )
                    else:
                        failures += 1
                        logger.debug(
                            f"[ExploitAgent] ✓ EXPLOIT BLOCKED: {payload.payload_id} "
                            f"on {candidate.candidate_id}"
                        )
                except Exception as e:
                    attempts += 1
                    failures += 1
                    logger.warning(
                        f"[ExploitAgent] Payload {payload.payload_id} error: {e}"
                    )

        elapsed_ms = (time.time() - t_start) * 1000
        candidate.exploit_attempts = attempts
        candidate.exploit_successes = successes
        candidate.exploit_failures = failures
        candidate.exploit_success_rate = successes / max(attempts, 1)
        candidate.exploit_latency_ms = elapsed_ms

        logger.info(
            f"[ExploitAgent] {candidate.candidate_id}: "
            f"{successes}/{attempts} exploits succeeded "
            f"({candidate.exploit_success_rate:.0%} vuln rate) "
            f"in {elapsed_ms:.1f}ms"
        )
        return candidate

    async def _fire_payload(
        self,
        client: httpx.AsyncClient,
        base_url: str,
        payload: ExploitPayload,
    ) -> Dict[str, Any]:
        """Fire one payload and determine if exploit succeeded."""
        url = f"{base_url}{payload.target_endpoint}"

        if payload.method == "GET":
            response = await client.get(url, params=payload.params)
        else:
            response = await client.post(url, json=payload.body)

        body_text = response.text

        # Exploit succeeds if the vuln indicator is in the response
        # and we did NOT get a 400/403 (which means it was blocked)
        blocked_by_status = response.status_code in (400, 403, 422)
        indicator_present = payload.expected_vuln_indicator.lower() in body_text.lower()

        exploited = indicator_present and not blocked_by_status

        return {
            "payload_id": payload.payload_id,
            "status_code": response.status_code,
            "exploited": exploited,
            "blocked_by_status": blocked_by_status,
            "indicator_present": indicator_present,
        }

    def run_sync(self, candidate: CandidateResult, target_url: Optional[str] = None) -> CandidateResult:
        """Synchronous wrapper for replay_against_candidate."""
        return asyncio.run(self.replay_against_candidate(candidate, target_url))
